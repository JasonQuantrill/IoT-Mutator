rule "Irrigation - calculate whether to start watering"
when
    Time cron "0 * * ? * *" 
then
	try {
		logInfo(logName, "Calculating whether to start irrigation")

		
		SumRainLast24h.sendCommand((WeatherAndForecastCurrentRain.sumSince(now.minusHours(24), "influxdb") as Number).doubleValue)
		SumRainNext24h.sendCommand(GroupForecastedRain24Sum.state as Number)

		
		Thread.sleep(200)

		logDebug(logName, "Rain - last 24h (sum): {} mm", String::format("%.2f", (SumRainLast24h.state as Number).doubleValue))
		logDebug(logName, "Rain - forecast 24h (sum): {} mm", String::format("%.2f", (SumRainNext24h.state as Number).doubleValue))

		
		
		

		
		if (IrrigationLock.state == ON) {
			logInfo(logName, "Irrigation lock is on")
			return
		}

		
		val Number day = now.getDayOfWeek()
		val dayItem = ScriptServiceUtil.getItemRegistry.getItem("IrrigationDay" + day)
		
		if (dayItem === null || dayItem.state == OFF || dayItem.state == NULL) {
			logInfo(logName, "Inappropriate day to start irrigation", dayItem)
			return
		}

		
		val localSunRise = new DateTime(LocalSunRiseStart.state.toString).minusHours((IrrigationHoursBeforeSunrise.state as Number).intValue)
		var Number wateringHour = localSunRise.getHourOfDay()
		var Number wateringMinute = localSunRise.getMinuteOfHour()

		
		if (IrrigationStartAtSpecificHour.state == ON) {
			wateringHour = IrrigationStartTime.state as Number
			wateringMinute = 0
		}

		logInfo(logName, "Watering at: {}:{}", wateringHour, wateringMinute)

		
		if (now.getHourOfDay != wateringHour || now.getMinuteOfHour != wateringMinute) {
			
			logInfo(logName, "Inappropriate time to start irrigation")
			return
		}
		logInfo(logName, "It is watering hour: {}:{}", wateringHour, wateringMinute)

		
		logInfo(logName, "Current wind speed: {} km/h", String::format("%.2f", (WeatherAndForecastCurrentWindSpeed.state as Number).doubleValue))
		if (WeatherAndForecastCurrentWindSpeed.state > MaxAllowedWindSpeed.state as Number) {
			logInfo(logName, "Wind speed too high to irrigate")
			return
		}

		
		val rainSum = (SumRainLast24h.state as Number).doubleValue + (SumRainNext24h.state as Number).doubleValue
		logInfo(logName, "Past and forcasted average rain: {} mm", String::format("%.2f", rainSum))
		if (rainSum > (MaxAllowedRain.state as Number).doubleValue) {
			logInfo(logName, "To heavy rain to irrigate (past and forcasted)")
			return
		}

		
		
		val avgTemperatureLast24h = (WeatherAndForecastCurrentTemperature.averageSince(now.minusHours(24), "influxdb") as Number).doubleValue

		logInfo(logName, "Average temperature for the last 24h: {}", avgTemperatureLast24h)

		if (avgTemperatureLast24h <= 10) {
			logInfo(logName, "Temperature too low to start irrigation")
			return
		} 
		else if (avgTemperatureLast24h > 30) {
			logInfo(logName, "Setting irrigation coefficient factor to 2")
		} 
		else {
			
			
			coefficientFactor = avgTemperatureLast24h / 10 - 1;
			logInfo(logName, "Setting irrigation coefficient factor to {}", coefficientFactor)
		}

		
		
		

		
		logInfo(logName, "Starting the irrigation sequence")
		IrrigationCurrentValve.sendCommand(IrrigationValveZone1.name)
	}
	catch (Exception e) {
        logError(logName, "Error calculating whether to start irrigation: " + e)
    }
end

rule "Irrigation - all valves closed"
when
	Item GroupIrrigationValves changed to OFF
then
	
	logInfo(logName, "All irrigation valves closed")
	IrrigationCurrentValve.postUpdate(OFF)

	
	IrrigationSectionRemainingTime.postUpdate(0)
end